name: Windows Build and Release

# 仅在创建新Release时触发
on:
  release:
    types: [created]
  push:
    branches: [ "master" ]
    paths-ignore:
      - '**.md'  # 忽略所有Markdown文件的修改
      - 'docs/**'  # 忽略docs目录下的修改

# 必要的权限配置
permissions:
  contents: write  # 允许上传构建产物

jobs:
  build-windows:
    runs-on: windows-latest
    outputs:
      zip-name: ${{ steps.package.outputs.zip-name }}  # 输出zip文件名供后续步骤使用
    permissions: write-all

    steps:
      - name: 拉取代码
        uses: actions/checkout@v4

      - name: 安装Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
          target: x86_64-pc-windows-msvc  # Windows x64目标

      - name: 构建Release版本
        run: cargo build --release --target x86_64-pc-windows-msvc

      - name: 准备打包文件
        shell: pwsh
        run: |
          # 创建临时打包目录
          New-Item -ItemType Directory -Path release_dir | Out-Null
          
          # 复制可执行文件（替换为你的项目名称）
          $exePath = "target/x86_64-pc-windows-msvc/release/nuna.exe"
          Copy-Item -Path $exePath -Destination "release_dir/"
          
          # 复制Interception目录（保持结构）
          if (Test-Path "Interception") {
              Copy-Item -Path "Interception" -Destination "release_dir/" -Recurse
          } else {
              Write-Warning "Interception目录未找到"
          }

      - name: 打包为zip并输出文件名
        id: package
        shell: pwsh
        run: |
          # 根据触发条件生成不同的文件名
          if ("${{ github.event_name }}" -eq "release") {
              $version = "${{ github.ref_name }}"
              $zipName = "nuna-windows-x64-$version.zip"
          } else {
              $commitHash = "${{ github.sha }}".Substring(0, 8)
              $zipName = "nuna-windows-x64-$commitHash.zip"
          }
          # 执行打包
          Compress-Archive -Path "release_dir/*" -DestinationPath $zipName -Force
          
          # 再次验证文件存在
          if (-not (Test-Path $zipName)) {
              Write-Error "打包失败，未生成 $zipName"
              exit 1
          }
          
          # 关键修复：正确使用正确的PowerShell语法输出环境变量
          echo "zip-name=$zipName" >> $env:GITHUB_OUTPUT
          
          # 调试输出
          Write-Host "生成的ZIP文件: $zipName"
          Write-Host "输出变量: $(Get-Content $env:GITHUB_OUTPUT)"

      - name: 临时保存ZIP文件
        uses: actions/upload-artifact@v4
        with:
          name: temp-build-zip  # 临时工件名称
          path: ${{ steps.package.outputs.zip-name }}
          retention-days: 1  # 临时保存1天


  # 创建Release时：上传到GitHub Releases
  upload-release:
    needs: build-windows
    if: github.event_name == 'release'  # 仅在release事件时执行
    runs-on: windows-latest
    steps:
      - name: 下载临时ZIP文件
        uses: actions/download-artifact@v4
        with:
          name: temp-build-zip

      - name: 上传到GitHub Releases
        uses: softprops/action-gh-release@v2
        with:
          files: ${{ needs.build-windows.outputs.zip-name }}
          draft: false
          prerelease: false

  # main分支变动时：上传到Actions工件
  upload-artifact:
    needs: build-windows
    if: github.event_name == 'push'  # 仅在push事件时执行
    runs-on: windows-latest
    steps:
      - name: 显示构建产物名称（调试用）
        run: |
          echo "需要上传的文件: ${{ needs.build-windows.outputs.zip-name }}"
        shell: pwsh

      # 新增步骤：下载临时工件（获取build-windows生成的ZIP）
      - name: 下载临时ZIP文件
        uses: actions/download-artifact@v4
        with:
          name: temp-build-zip  # 与上传时的名称一致

      - name: 验证文件存在性
        shell: pwsh
        run: |
          $zipName = "${{ needs.build-windows.outputs.zip-name }}"
          if ([string]::IsNullOrEmpty($zipName)) {
              Write-Error "zip-name为空，无法继续"
              exit 1
          }
          if (-not (Test-Path $zipName)) {
              Write-Error "文件 $zipName 不存在"
              exit 1
          }


      - name: 上传构建产物到工件
        uses: actions/upload-artifact@v4
        with:
          name: windows-build-${{ github.sha }}
          path: ${{ needs.build-windows.outputs.zip-name }}
          retention-days: 7  # 保留7天
